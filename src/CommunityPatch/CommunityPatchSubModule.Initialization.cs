using System;
using System.Diagnostics;
using System.Reflection;
using System.Reflection.Emit;
using System.Runtime.CompilerServices;
using System.Runtime.InteropServices;
using HarmonyLib;
using Sigil;
using Sigil.NonGeneric;
using TaleWorlds.CampaignSystem;
using TaleWorlds.Core;
using TaleWorlds.Localization;
using static CommunityPatch.CommunityPatchSubModule;

namespace CommunityPatch {

  public partial class CommunityPatchSubModule {

    static CommunityPatchSubModule() {
      CallStackHelpers.Init();
      // catch and record exceptions
      AppDomain.CurrentDomain.FirstChanceException += (sender, args) => {
        if (RecordFirstChanceExceptions)
          RecordedFirstChanceExceptions.AddLast(args.Exception);
      };
      AppDomain.CurrentDomain.UnhandledException += (sender, args) => {
        RecordedUnhandledExceptions.AddLast((Exception) args.ExceptionObject);
        if (args.IsTerminating)
          Diagnostics.GenerateReport();
        else
          Diagnostics.QueueGenerateReport();
      };

      try {
        Harmony.Patch(
          Type.GetType("ManagedCallbacks.EngineCallbacksGenerated, TaleWorlds.Engine.AutoGenerated, Version=1.0.0.0, Culture=neutral")
            .GetMethod("ScreenManager_PreTick", BindingFlags.Public | BindingFlags.NonPublic | BindingFlags.Static | BindingFlags.DeclaredOnly),
          finalizer: new HarmonyMethod(typeof(CommunityPatchSubModule).GetMethod(nameof(TerminalTickExceptionPatch), BindingFlags.NonPublic | BindingFlags.Static | BindingFlags.DeclaredOnly))
        );
      }
      catch (Exception ex) {
        Error(ex, "Couldn't apply screen manager pre-tick exception catcher patch.");
      }

      try {
        Harmony.Patch(
          Type.GetType("ManagedCallbacks.EngineCallbacksGenerated, TaleWorlds.Engine.AutoGenerated, Version=1.0.0.0, Culture=neutral")
            .GetMethod("ScreenManager_Tick", BindingFlags.Public | BindingFlags.NonPublic | BindingFlags.Static | BindingFlags.DeclaredOnly),
          finalizer: new HarmonyMethod(typeof(CommunityPatchSubModule).GetMethod(nameof(TerminalTickExceptionPatch), BindingFlags.NonPublic | BindingFlags.Static | BindingFlags.DeclaredOnly))
        );
      }
      catch (Exception ex) {
        Error(ex, "Couldn't apply screen manager tick exception catcher patch.");
      }

      try {
        Harmony.Patch(
          Type.GetType("ManagedCallbacks.ScriptingInterfaceOfIScene, TaleWorlds.Engine.AutoGenerated, Version=1.0.0.0, Culture=neutral")
            .GetMethod("Tick", BindingFlags.Public | BindingFlags.NonPublic | BindingFlags.Instance | BindingFlags.DeclaredOnly),
          finalizer: new HarmonyMethod(typeof(CommunityPatchSubModule).GetMethod(nameof(TerminalSceneTickExceptionPatch), BindingFlags.NonPublic | BindingFlags.Static | BindingFlags.DeclaredOnly))
        );
      }
      catch (Exception ex) {
        Error(ex, "Couldn't apply scene scripting interface tick exception catcher patch.");
      }

      try {
        Harmony.Patch(
          Type.GetType("ManagedCallbacks.EngineCallbacksGenerated, TaleWorlds.Engine.AutoGenerated, Version=1.0.0.0, Culture=neutral")
            .GetMethod("ScriptComponentBehaviour_OnTick", BindingFlags.Public | BindingFlags.NonPublic | BindingFlags.Static | BindingFlags.DeclaredOnly),
          finalizer: new HarmonyMethod(typeof(CommunityPatchSubModule).GetMethod(nameof(TerminalTickExceptionPatch), BindingFlags.NonPublic | BindingFlags.Static | BindingFlags.DeclaredOnly))
        );
      }
      catch (Exception ex) {
        Error(ex, "Couldn't apply script component tick exception catcher patch.");
      }

      try {
        Harmony.Patch(
          Type.GetType("ManagedCallbacks.EngineCallbacksGenerated, TaleWorlds.Engine.AutoGenerated, Version=1.0.0.0, Culture=neutral")
            .GetMethod("ManagedScriptHolder_TickComponents", BindingFlags.Public | BindingFlags.NonPublic | BindingFlags.Static | BindingFlags.DeclaredOnly),
          finalizer: new HarmonyMethod(typeof(CommunityPatchSubModule).GetMethod(nameof(TerminalTickExceptionPatch), BindingFlags.NonPublic | BindingFlags.Static | BindingFlags.DeclaredOnly))
        );
      }
      catch (Exception ex) {
        Error(ex, "Couldn't apply script holder component tick exception catcher patch.");
      }

      try {
        Harmony.Patch(
          Type.GetType("ManagedCallbacks.LibraryCallbacksGenerated, TaleWorlds.DotNet.AutoGenerated, Version=1.0.0.0, Culture=neutral")
            .GetMethod("Managed_ApplicationTick", BindingFlags.Public | BindingFlags.NonPublic | BindingFlags.Static | BindingFlags.DeclaredOnly),
          finalizer: new HarmonyMethod(typeof(CommunityPatchSubModule).GetMethod(nameof(TerminalTickExceptionPatch), BindingFlags.NonPublic | BindingFlags.Static | BindingFlags.DeclaredOnly))
        );
      }
      catch (Exception ex) {
        Error(ex, "Couldn't apply application tick exception catcher patch.");
      }

      try {
        Harmony.Patch(
          Type.GetType("TaleWorlds.SaveSystem.Load.ObjectHeaderLoadData, TaleWorlds.SaveSystem, Version=1.0.0.0, Culture=neutral")
            .GetMethod("get_TypeDefinition", BindingFlags.Public | BindingFlags.NonPublic | BindingFlags.Instance | BindingFlags.DeclaredOnly),
          postfix: new HarmonyMethod(typeof(CommunityPatchSubModule).GetMethod(nameof(SaveIdNotResolvedReporterPatch), BindingFlags.NonPublic | BindingFlags.Static | BindingFlags.DeclaredOnly))
        );
      }
      catch (Exception ex) {
        Error(ex, "Couldn't apply application tick exception catcher patch.");
      }

      // 
    }

    // ReSharper disable once InconsistentNaming
    [MethodImpl(MethodImplOptions.NoInlining)]
    private static Exception TerminalSceneTickExceptionPatch(Exception __exception, UIntPtr scenePointer, float deltaTime) {
      if (__exception == null)
        return null;

      RecordedUnhandledExceptions.AddLast(__exception);

      if (SuppressTerminalTickExceptions) {
        Diagnostics.QueueGenerateReport();
        return null;
      }

      Diagnostics.GenerateReport();

      return __exception;
    }

    // ReSharper disable once InconsistentNaming
    [MethodImpl(MethodImplOptions.NoInlining)]
    private static Exception TerminalTickExceptionPatch(Exception __exception) {
      if (__exception == null)
        return null;

      RecordedUnhandledExceptions.AddLast(__exception);

      if (SuppressTerminalTickExceptions) {
        Diagnostics.QueueGenerateReport();
        return null;
      }

      Diagnostics.GenerateReport();
      return __exception;
    }

    private static readonly Type SaveTypeDefType = Type.GetType("TaleWorlds.SaveSystem.Definition.TypeDefinition, TaleWorlds.SaveSystem, Version=1.0.0.0, Culture=neutral");

    private static readonly Type SaveIdType = Type.GetType("TaleWorlds.SaveSystem.Definition.SaveId, TaleWorlds.SaveSystem, Version=1.0.0.0, Culture=neutral");

    private static readonly MethodInfo SaveIdGetStringId = SaveIdType.GetMethod("GetStringId", BindingFlags.Public | BindingFlags.NonPublic | BindingFlags.Instance | BindingFlags.DeclaredOnly);

    private static readonly ConstructorInfo SaveTypeDefCtor = SaveTypeDefType.GetConstructor(BindingFlags.Public | BindingFlags.NonPublic | BindingFlags.Instance, null, new Type[] {typeof(Type), SaveIdType}, null);

    private static readonly AssemblyBuilder DynAsm = AssemblyBuilder.DefineDynamicAssembly(new AssemblyName("CommunityPatchSubModuleDynamicAssembly"), AssemblyBuilderAccess.RunAndCollect);

    private static readonly ModuleBuilder DynMod = DynAsm.DefineDynamicModule("CommunityPatchSubModuleDynamicAssembly");

    private static readonly ConstructorInfo SaveIdTypeMissingQuestCtor = typeof(SaveIdTypeMissingQuest).GetConstructor(BindingFlags.NonPublic | BindingFlags.Instance | BindingFlags.DeclaredOnly, null,
      new Type[] {typeof(string), typeof(Hero), typeof(CampaignTime), typeof(int), typeof(string)}, null);

    private static void SaveIdNotResolvedReporterPatch(ref object __result, ref object ____saveId) {
      if (__result != null)
        return;

      var saveIdStr = (string) SaveIdGetStringId.Invoke(____saveId, new object[0]);

      // check call stack to figure out what type this should be
      var callerFrame = new StackFrame(2);

      Error("Stack Trace: " + Environment.StackTrace);

      {
        __result = CreateMissingSaveIdQuest(____saveId, saveIdStr);
        return;
      }
    }

    private static object CreateMissingSaveIdQuest(object saveIdObj, string saveIdStr) {
      // quest
      var typeName = "SaveId_" + saveIdStr;
      var saveIdType = DynMod.GetType(typeName, false, false);
      if (saveIdType == null) {
        var tb = DynMod.DefineType(typeName, TypeAttributes.Class | TypeAttributes.Sealed | TypeAttributes.Public, typeof(SaveIdTypeMissingQuest));
        var ctorBuilder = Emit.BuildConstructor(new Type[] {typeof(string), typeof(Hero), typeof(CampaignTime), typeof(int)}, tb, MethodAttributes.Public);
        for (ushort i = 0; i <= 4; ++i)
          ctorBuilder.LoadArgument(i);
        ctorBuilder.LoadConstant(saveIdStr);
        ctorBuilder.Call(SaveIdTypeMissingQuestCtor);
        ctorBuilder.Return();
        ctorBuilder.CreateConstructor();
        saveIdType = tb.CreateTypeInfo();
      }

      var typeDef = SaveTypeDefCtor.Invoke(new[] {saveIdType, saveIdObj});
      //Error($"Caller: {callerFrame.GetMethod().FullDescription()}");
      Error($"Save Id not resolved: {saveIdStr}");
      return typeDef;
    }

  }

  public abstract class SaveIdTypeMissingQuest : QuestBase {

    protected SaveIdTypeMissingQuest(string questId, Hero questGiver, CampaignTime duration, int rewardGold, string saveId)
      : base(questId, questGiver, duration, rewardGold) {
      var msg = FormattableString.Invariant($"Missing SaveId {saveId} for Quest: {questId}.");

      Title = new TextObject($"<{msg}>");
    }

    protected override void SetDialogs() {
    }

    protected override void InitializeQuestOnGameLoad() {
    }

    public override TextObject Title { get; }

    public override bool IsRemainingTimeHidden => false;

  }

}