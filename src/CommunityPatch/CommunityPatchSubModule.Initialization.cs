using System;
using System.Reflection;
using HarmonyLib;

namespace CommunityPatch {

  public partial class CommunityPatchSubModule {

    static CommunityPatchSubModule() {
      // catch and record exceptions
      AppDomain.CurrentDomain.FirstChanceException += (sender, args) => {
        if (RecordFirstChanceExceptions)
          RecordedFirstChanceExceptions.AddLast(args.Exception);
      };
      AppDomain.CurrentDomain.UnhandledException += (sender, args) => {
        RecordedUnhandledExceptions.AddLast((Exception) args.ExceptionObject);
        CopyDiagnosticsToClipboard();
      };

      try {
        Harmony.Patch(
          Type.GetType("ManagedCallbacks.LibraryCallbacksGenerated, TaleWorlds.DotNet.AutoGenerated, Version=1.0.0.0, Culture=neutral")
            .GetMethod("Managed_ApplicationTick", BindingFlags.Public | BindingFlags.NonPublic | BindingFlags.Static | BindingFlags.DeclaredOnly),
          finalizer: new HarmonyMethod(typeof(CommunityPatchSubModule).GetMethod(nameof(TickFinalizerPatch), BindingFlags.NonPublic | BindingFlags.Static | BindingFlags.DeclaredOnly))
        );
      }
      catch (Exception ex) {
        Error(ex, "Couldn't apply tick exception catcher patch.");
      }
    }

    // ReSharper disable once InconsistentNaming
    private static void TickFinalizerPatch(Exception __exception) {
      if (__exception == null)
        return;

      RecordedUnhandledExceptions.AddLast(__exception);
      CopyDiagnosticsToClipboard();
    }

  }

}